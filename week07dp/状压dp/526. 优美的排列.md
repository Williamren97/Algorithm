526. 优美的排列
已解答
算术评级: 6
 同步题目状态

中等
相关标签
相关企业
假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：

perm[i] 能够被 i 整除
i 能够被 perm[i] 整除
给你一个整数 n ，返回可以构造的 优美排列 的 数量 。

 

示例 1：

输入：n = 2
输出：2
解释：
第 1 个优美的排列是 [1,2]：
    - perm[1] = 1 能被 i = 1 整除
    - perm[2] = 2 能被 i = 2 整除
第 2 个优美的排列是 [2,1]:
    - perm[1] = 2 能被 i = 1 整除
    - i = 2 能被 perm[2] = 1 整除
示例 2：

输入：n = 1
输出：1
 

提示：

1 <= n <= 15

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int countArrangement(int n) {
        // 使用 HashMap 缓存状态，避免重复计算
        Map<String, Integer> cache = new HashMap<>();
        // 布尔数组，表示数字 1 到 n 是否已经使用
        boolean[] used = new boolean[n + 1];
        return dfs(n, 1, used, cache);
    }

    // 深度优先搜索函数
    private int dfs(int n, int pos, boolean[] used, Map<String, Integer> cache) {
        if (pos > n) {
            // 如果位置超过了 n，表示成功构建了一个优美排列
            return 1;
        }

        // 将当前状态编码为字符串用于缓存
        String key = encodeState(used);
        // 如果缓存中存在当前状态，则直接返回缓存结果
        if (cache.containsKey(key)) {
            return cache.get(key);
        }

        int count = 0;
        // 尝试将每个数字放在当前的 pos 位置
        for (int num = 1; num <= n; num++) {
            // 检查 num 是否已被使用，并且满足条件
            if (!used[num] && (num % pos == 0 || pos % num == 0)) {
                // 标记 num 为已使用
                used[num] = true;
                // 递归调用，尝试在下一个位置放置其他数字
                count += dfs(n, pos + 1, used, cache);
                // 回溯，取消 num 的使用标记
                used[num] = false;
            }
        }

        // 缓存当前状态的结果
        cache.put(key, count);
        return count;
    }

    // 将布尔数组编码为字符串，用于缓存的键
    private String encodeState(boolean[] used) {
        StringBuilder sb = new StringBuilder();
        for (boolean b : used) {
            sb.append(b ? '1' : '0');
        }
        return sb.toString();
    }
}



// import java.util.HashMap;
// import java.util.Map;

// class Solution {
//     public int countArrangement(int n) {
//         // 使用 HashMap 缓存状态，避免重复计算
//         Map<Integer, Integer> cache = new HashMap<>();
//         return dfs(n, 0, 1, cache);
//     }

//     // 深度优先搜索函数
//     private int dfs(int n, int state, int pos, Map<Integer, Integer> cache) {
//         if (pos > n) {
//             // 如果位置超过了 n，表示成功构建了一个优美排列
//             return 1;
//         }

//         // 如果缓存中存在当前状态，则直接返回缓存结果
//         if (cache.containsKey(state)) {
//             return cache.get(state);
//         }

//         int count = 0;
//         // 尝试将每个数字放在当前的 pos 位置
//         for (int num = 1; num <= n; num++) {
//             // 检查 num 是否已被使用，如果没有被使用并且满足条件
            // if ((state & (1 << num)) == 0 && (num % pos == 0 || pos % num == 0)) {
            //     // 递归调用，尝试在下一个位置放置其他数字
            //     count += dfs(n, state | (1 << num), pos + 1, cache);
            // }
//         }

//         // 缓存当前状态的结果
//         cache.put(state, count);
//         return count;
//     }
// }

```
