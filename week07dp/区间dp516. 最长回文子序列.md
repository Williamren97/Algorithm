```java
//区间dp
// 对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] f = new int[n][n];
        //j 的范围是从 i+1 = 5 到 n-1 = 4。因为 5 不小于 5，所以内层循环不会执行。 s[4][5]不合格，接着处理s[3][4]
        for (int i = n - 1; i >=0 ;i--) {
            //任何长度为 1 的子序列都是回文子序列
            f[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i + 1][j -  1] + 2;
                } else {
                    //不可能同时作为同一个回文子序列的首尾
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);;
                }
            }
        }
        return f[0][n - 1];
    }
}
```
具体例子解释
对于 s = "bbbab"，n = 5。我们来看一下循环的具体执行情况：

当 i = 4 时：

j 的范围是从 i+1 = 5 到 n-1 = 4。
因为 5 不小于 5，所以内层循环不会执行。
当 i = 3 时：

j 的范围是从 i+1 = 4 到 n-1 = 4。
因此，j 只会是 4，即处理 s[3..4]。
当 i = 2 时：

j 的范围是从 i+1 = 3 到 n-1 = 4。
因此，j 会是 3 和 4，即处理 s[2..3] 和 s[2..4]。
当 i = 1 时：

j 的范围是从 i+1 = 2 到 n-1 = 4。
因此，j 会是 2、3 和 4，即处理 s[1..2]、s[1..3] 和 s[1..4]。
当 i = 0 时：

j 的范围是从 i+1 = 1 到 n-1 = 4。
因此，j 会是 1、2、3 和 4，即处理 s[0..1]、s[0..2]、s[0..3] 和 s[0..4]。



子字符串长度为 2：
对于 s[3..4] = "ab"：
i = 3
j = 4
因为 s[3] != s[4]，所以 f[3][4] = max(f[4][4], f[3][3]) = 1
子字符串长度为 3：
对于 s[2..4] = "bab"：
i = 2
j = 4
因为 s[2] == s[4]，所以 f[2][4] = f[3][3] + 2 = 1 + 2 = 3
子字符串长度为 4：
对于 s[1..4] = "bbab"：

i = 1
j = 4
因为 s[1] == s[4]，所以 f[1][4] = f[2][3] + 2 = 1 + 2 = 3
对于 s[0..3] = "bbba"：

i = 0
j = 3
因为 s[0] == s[3]，所以 f[0][3] = f[1][2] + 2 = 1 + 2 = 3
